name: CI

on:
  push:
    branches: [main, "renovate/**"]
  pull_request:

concurrency:
  cancel-in-progress: true
  group: ${{ github.workflow }}-${{ github.event.number || github.ref }}

# Adapted from https://github.com/nrwl/ci/blob/v0.14.0/.github/workflows/nx-cloud-main.yml
env:
  NX_BRANCH: ${{ github.event.number || github.ref_name }}

jobs:
  pull-request:
    if: github.event_name == 'pull_request' || github.ref != 'refs/heads/main'
    runs-on: [self-hosted, cbh-amazon-linux-2023]
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v6
        if: github.event_name == 'pull_request'
        with:
          fetch-depth: 0
          # GitHub checks PRs out based on the merge commit; we want the branch HEAD.
          ref: ${{ github.event.pull_request.head.sha }}
      - uses: actions/checkout@v6
        if: github.event_name != 'pull_request'
        with:
          fetch-depth: 0
      - run: git fetch origin main:main
      - uses: ./.github/actions/setup-node

      - run: docker compose up -d --wait --wait-timeout 120
      - run: npm run ci:install
      - run: npm run ci:check
      # Don't use the read-write NX_CLOUD_ACCESS_TOKEN when not on `main`, see https://nx.dev/ci/concepts/cache-security#use-a-readwrite-token-in-ci
      - run: npx nx affected --configuration ci --targets build,lint,test
      - run: docker compose down --volumes
        if: always()

  main:
    if: github.ref == 'refs/heads/main'
    permissions:
      actions: read
      contents: write
      id-token: write
    runs-on: [self-hosted, cbh-amazon-linux-2023]
    timeout-minutes: 15
    steps:
      - id: token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ steps.token.outputs.token }}
      - uses: ./.github/actions/setup-node

      - run: docker compose up -d --wait --wait-timeout 120
      - run: npm run ci:install
      - run: npm run ci:check
      # Skip the cache and use the read-write NX_CLOUD_ACCESS_TOKEN on `main`, see https://nx.dev/ci/concepts/cache-security#skip-the-cache-when-creating-a-deployment-artifact
      - run: npx nx affected --configuration ci --skip-nx-cache --target build
        env:
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}
      # Lint and test can use the cache; only build needs --skip-nx-cache for deployment artifact integrity
      - run: npx nx affected --configuration ci --targets lint,test
        env:
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}
      - run: docker compose down --volumes
        if: always()

      - run: |
          git config user.name "GitHub Bot"
          git config user.email "open-source@clipboardhealth.com"
      - env:
          GH_TOKEN: ${{ steps.token.outputs.token }}
          NX_RELEASE: true
        # Version package.json files at project roots
        run: npx tsx scripts/release.ts
        # Run a build so package.json files in dist directories pick up new versions
      - run: npx nx run-many --target=build
      - env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_PUBLISH_TOKEN }}
        # Re-publishing an existing version is a no-op, so re-running this workflow recovers from transient NPM registry failures
        run: npx nx release publish
      - env:
          GH_TOKEN: ${{ steps.token.outputs.token }}
        # Commit mismatched package.json versions and package-lock.json changes, if any
        run: |
          npx syncpack fix-mismatches &&
          npm install &&
          git add package.json packages/*/package.json package-lock.json &&
          git diff --staged --quiet || git commit -m "chore(release): sync package versions [skip actions]" --no-verify &&
          git push
      - run: npm run docs
      - uses: JamesIves/github-pages-deploy-action@v4
        with:
          branch: gh-pages
          folder: docs
